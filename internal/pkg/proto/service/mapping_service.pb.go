// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mapping_service.proto

package service

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	mapping "github.com/uibricks/studio-engine/internal/pkg/proto/mapping"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("mapping_service.proto", fileDescriptor_5f0d5e8c2fe5fc8c) }

var fileDescriptor_5f0d5e8c2fe5fc8c = []byte{
	// 422 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xcd, 0xca, 0xd3, 0x40,
	0x18, 0x85, 0x93, 0x85, 0x0a, 0x23, 0x7e, 0xe8, 0x80, 0x7c, 0x9a, 0xea, 0xf8, 0xb7, 0x6e, 0x03,
	0xba, 0x15, 0x44, 0x69, 0xf0, 0x07, 0x14, 0x4d, 0x11, 0x41, 0x50, 0x49, 0xd2, 0xd7, 0x38, 0x36,
	0x9d, 0x19, 0x67, 0x26, 0xa1, 0xde, 0x85, 0x97, 0xe1, 0x25, 0xb8, 0x74, 0xd9, 0x65, 0x97, 0x2e,
	0x6d, 0xba, 0xf2, 0x0e, 0x5c, 0x0a, 0x99, 0x99, 0x34, 0x36, 0x6d, 0x57, 0xed, 0x7b, 0x9e, 0x73,
	0x9e, 0x4d, 0x18, 0x74, 0x79, 0x9e, 0x08, 0x41, 0x59, 0xfe, 0x41, 0x81, 0xac, 0x68, 0x06, 0x23,
	0x21, 0xb9, 0xe6, 0xf8, 0x9c, 0x3d, 0x83, 0x61, 0x4e, 0xf5, 0xa7, 0x32, 0x1d, 0x65, 0x7c, 0x1e,
	0xe6, 0x3c, 0xe7, 0x61, 0xc3, 0xd3, 0xf2, 0x63, 0x73, 0x35, 0x47, 0xf3, 0xcf, 0xec, 0x02, 0xa7,
	0x0b, 0xed, 0xaf, 0x89, 0xef, 0xfe, 0x39, 0x83, 0x4e, 0x9e, 0x9b, 0x64, 0x62, 0xc4, 0xf8, 0x01,
	0x42, 0x8f, 0x41, 0xdb, 0x10, 0x9f, 0x8e, 0xdc, 0xc0, 0x26, 0x31, 0x7c, 0x29, 0x41, 0xe9, 0xe0,
	0x4a, 0x1f, 0x28, 0xc1, 0x99, 0x02, 0xfc, 0x04, 0x9d, 0x9f, 0x24, 0x15, 0x38, 0xc3, 0xa0, 0x2d,
	0x76, 0x52, 0x67, 0xb9, 0xb6, 0x1f, 0x5a, 0xd3, 0x0b, 0x74, 0x61, 0x0c, 0x05, 0xe8, 0xd6, 0x75,
	0xbd, 0xad, 0xff, 0x97, 0x3b, 0x1b, 0x39, 0x84, 0xad, 0xef, 0x0d, 0xba, 0x68, 0x40, 0x0c, 0x82,
	0x2b, 0xaa, 0xb9, 0xfc, 0x8a, 0x6f, 0xee, 0x6c, 0xb6, 0xc8, 0x59, 0x6f, 0x1d, 0x69, 0x58, 0xf1,
	0x7b, 0x74, 0xfa, 0x5a, 0x4c, 0x93, 0x2e, 0x1b, 0x83, 0x4e, 0x68, 0xa1, 0x3a, 0xfe, 0xdd, 0x46,
	0xdf, 0xdf, 0x6f, 0x58, 0xff, 0x33, 0x74, 0xc9, 0xb0, 0x88, 0x55, 0x54, 0x72, 0x36, 0x07, 0xa6,
	0xf1, 0xd5, 0x9d, 0x5d, 0xc4, 0x2a, 0xa7, 0x0c, 0xf6, 0x21, 0xeb, 0x8a, 0x10, 0x8a, 0x16, 0x90,
	0x95, 0x1a, 0x1e, 0xbe, 0x7c, 0x8a, 0xb7, 0x4d, 0x17, 0x0a, 0xea, 0x2c, 0x83, 0xbd, 0xcc, 0x6a,
	0xde, 0x21, 0x1c, 0x83, 0xe2, 0x45, 0x05, 0xd1, 0x42, 0x48, 0x50, 0x8a, 0x72, 0xa6, 0xf0, 0xed,
	0x76, 0xd2, 0x87, 0x4e, 0x7b, 0xe7, 0x68, 0xc7, 0xea, 0x5f, 0xa1, 0x93, 0x18, 0x94, 0xe6, 0xb2,
	0xfd, 0xf6, 0xa4, 0x3b, 0xeb, 0x00, 0xa7, 0xbd, 0x71, 0x90, 0x1b, 0xe5, 0xa3, 0xcf, 0xcb, 0x35,
	0xf1, 0xfe, 0xae, 0x89, 0xff, 0xbd, 0x26, 0xfe, 0x8f, 0x9a, 0xf8, 0x3f, 0x6b, 0xe2, 0x2f, 0x6b,
	0xe2, 0xaf, 0x6a, 0xe2, 0xff, 0xae, 0x89, 0xff, 0x6d, 0x43, 0xbc, 0xd5, 0x86, 0x78, 0xbf, 0x36,
	0xc4, 0x7b, 0x7b, 0xbf, 0xf3, 0xbe, 0x4a, 0x9a, 0x4a, 0x9a, 0xcd, 0x54, 0xa8, 0x74, 0x39, 0xa5,
	0x7c, 0x08, 0x2c, 0xa7, 0x0c, 0x42, 0xca, 0x34, 0x48, 0x96, 0x14, 0xa1, 0x98, 0xe5, 0xe6, 0xf9,
	0x85, 0xf6, 0x75, 0xa6, 0x67, 0x9b, 0xf3, 0xde, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa3, 0x4d,
	0x6b, 0xc4, 0xc6, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MappingServiceClient is the client API for MappingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MappingServiceClient interface {
	// This rpc returns the mapping info at project level
	// error handling
	// return NOT_FOUND if project not found
	GetMapping(ctx context.Context, in *mapping.MappingRequest, opts ...grpc.CallOption) (*mapping.MappingResponse, error)
	// unary rpc, updates the requested repository in cache. A new cache
	// will be created if it doesn't exist
	// error handling
	// return NOT_FOUND if repository not found
	SaveMapping(ctx context.Context, in *mapping.SaveMappingRequest, opts ...grpc.CallOption) (*mapping.SaveMappingResponse, error)
	// unary rpc, delete the mapping in cache as well as in DB for a given project id.
	// error handling
	// return NOT_FOUND if mapping not found for the given project id.
	DeleteMapping(ctx context.Context, in *mapping.DeleteMappingRequest, opts ...grpc.CallOption) (*mapping.DeleteMappingResponse, error)
	// unary rpc, delete the requested repository in cache. A new cache
	// will be created if it doesn't exist. And also checks the dependency of the requested
	// repository in other objects
	// error handling
	// return NOT_FOUND if repository not found
	DeleteRepository(ctx context.Context, in *mapping.DeleteRepositoryRequest, opts ...grpc.CallOption) (*mapping.DeleteRepositoryResponse, error)
	// unary rpc, updates repository menu and repositories for the specified project
	// error handling
	// returns NOT_FOUND if project not found
	UpdateRepositoryDetails(ctx context.Context, in *mapping.UpdateRepositoryRequest, opts ...grpc.CallOption) (*mapping.UpdateRepositoryResponse, error)
	// unary rpc, updates repository menu for the specified project
	// error handling
	// returns NOT_FOUND if project not found
	UpdateEnvironment(ctx context.Context, in *mapping.UpdateEnvRequest, opts ...grpc.CallOption) (*mapping.UpdateEnvResponse, error)
	ExecuteAPI(ctx context.Context, in *mapping.ExecuteApiRequest, opts ...grpc.CallOption) (*mapping.ExecuteApiResponse, error)
	ResolveExpressions(ctx context.Context, in *mapping.ResolveExpressionsRequest, opts ...grpc.CallOption) (*mapping.ResolveExpressionsResponse, error)
	// unary rpc, restores repository by clearing deleted_at
	RestoreMapping(ctx context.Context, in *mapping.RestoreMappingRequest, opts ...grpc.CallOption) (*mapping.RestoreMappingResponse, error)
}

type mappingServiceClient struct {
	cc *grpc.ClientConn
}

func NewMappingServiceClient(cc *grpc.ClientConn) MappingServiceClient {
	return &mappingServiceClient{cc}
}

func (c *mappingServiceClient) GetMapping(ctx context.Context, in *mapping.MappingRequest, opts ...grpc.CallOption) (*mapping.MappingResponse, error) {
	out := new(mapping.MappingResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/GetMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) SaveMapping(ctx context.Context, in *mapping.SaveMappingRequest, opts ...grpc.CallOption) (*mapping.SaveMappingResponse, error) {
	out := new(mapping.SaveMappingResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/SaveMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) DeleteMapping(ctx context.Context, in *mapping.DeleteMappingRequest, opts ...grpc.CallOption) (*mapping.DeleteMappingResponse, error) {
	out := new(mapping.DeleteMappingResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/DeleteMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) DeleteRepository(ctx context.Context, in *mapping.DeleteRepositoryRequest, opts ...grpc.CallOption) (*mapping.DeleteRepositoryResponse, error) {
	out := new(mapping.DeleteRepositoryResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/DeleteRepository", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) UpdateRepositoryDetails(ctx context.Context, in *mapping.UpdateRepositoryRequest, opts ...grpc.CallOption) (*mapping.UpdateRepositoryResponse, error) {
	out := new(mapping.UpdateRepositoryResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/UpdateRepositoryDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) UpdateEnvironment(ctx context.Context, in *mapping.UpdateEnvRequest, opts ...grpc.CallOption) (*mapping.UpdateEnvResponse, error) {
	out := new(mapping.UpdateEnvResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/UpdateEnvironment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) ExecuteAPI(ctx context.Context, in *mapping.ExecuteApiRequest, opts ...grpc.CallOption) (*mapping.ExecuteApiResponse, error) {
	out := new(mapping.ExecuteApiResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/ExecuteAPI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) ResolveExpressions(ctx context.Context, in *mapping.ResolveExpressionsRequest, opts ...grpc.CallOption) (*mapping.ResolveExpressionsResponse, error) {
	out := new(mapping.ResolveExpressionsResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/ResolveExpressions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingServiceClient) RestoreMapping(ctx context.Context, in *mapping.RestoreMappingRequest, opts ...grpc.CallOption) (*mapping.RestoreMappingResponse, error) {
	out := new(mapping.RestoreMappingResponse)
	err := c.cc.Invoke(ctx, "/service.MappingService/RestoreMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MappingServiceServer is the server API for MappingService service.
type MappingServiceServer interface {
	// This rpc returns the mapping info at project level
	// error handling
	// return NOT_FOUND if project not found
	GetMapping(context.Context, *mapping.MappingRequest) (*mapping.MappingResponse, error)
	// unary rpc, updates the requested repository in cache. A new cache
	// will be created if it doesn't exist
	// error handling
	// return NOT_FOUND if repository not found
	SaveMapping(context.Context, *mapping.SaveMappingRequest) (*mapping.SaveMappingResponse, error)
	// unary rpc, delete the mapping in cache as well as in DB for a given project id.
	// error handling
	// return NOT_FOUND if mapping not found for the given project id.
	DeleteMapping(context.Context, *mapping.DeleteMappingRequest) (*mapping.DeleteMappingResponse, error)
	// unary rpc, delete the requested repository in cache. A new cache
	// will be created if it doesn't exist. And also checks the dependency of the requested
	// repository in other objects
	// error handling
	// return NOT_FOUND if repository not found
	DeleteRepository(context.Context, *mapping.DeleteRepositoryRequest) (*mapping.DeleteRepositoryResponse, error)
	// unary rpc, updates repository menu and repositories for the specified project
	// error handling
	// returns NOT_FOUND if project not found
	UpdateRepositoryDetails(context.Context, *mapping.UpdateRepositoryRequest) (*mapping.UpdateRepositoryResponse, error)
	// unary rpc, updates repository menu for the specified project
	// error handling
	// returns NOT_FOUND if project not found
	UpdateEnvironment(context.Context, *mapping.UpdateEnvRequest) (*mapping.UpdateEnvResponse, error)
	ExecuteAPI(context.Context, *mapping.ExecuteApiRequest) (*mapping.ExecuteApiResponse, error)
	ResolveExpressions(context.Context, *mapping.ResolveExpressionsRequest) (*mapping.ResolveExpressionsResponse, error)
	// unary rpc, restores repository by clearing deleted_at
	RestoreMapping(context.Context, *mapping.RestoreMappingRequest) (*mapping.RestoreMappingResponse, error)
}

// UnimplementedMappingServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMappingServiceServer struct {
}

func (*UnimplementedMappingServiceServer) GetMapping(ctx context.Context, req *mapping.MappingRequest) (*mapping.MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMapping not implemented")
}
func (*UnimplementedMappingServiceServer) SaveMapping(ctx context.Context, req *mapping.SaveMappingRequest) (*mapping.SaveMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveMapping not implemented")
}
func (*UnimplementedMappingServiceServer) DeleteMapping(ctx context.Context, req *mapping.DeleteMappingRequest) (*mapping.DeleteMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMapping not implemented")
}
func (*UnimplementedMappingServiceServer) DeleteRepository(ctx context.Context, req *mapping.DeleteRepositoryRequest) (*mapping.DeleteRepositoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRepository not implemented")
}
func (*UnimplementedMappingServiceServer) UpdateRepositoryDetails(ctx context.Context, req *mapping.UpdateRepositoryRequest) (*mapping.UpdateRepositoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRepositoryDetails not implemented")
}
func (*UnimplementedMappingServiceServer) UpdateEnvironment(ctx context.Context, req *mapping.UpdateEnvRequest) (*mapping.UpdateEnvResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEnvironment not implemented")
}
func (*UnimplementedMappingServiceServer) ExecuteAPI(ctx context.Context, req *mapping.ExecuteApiRequest) (*mapping.ExecuteApiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteAPI not implemented")
}
func (*UnimplementedMappingServiceServer) ResolveExpressions(ctx context.Context, req *mapping.ResolveExpressionsRequest) (*mapping.ResolveExpressionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveExpressions not implemented")
}
func (*UnimplementedMappingServiceServer) RestoreMapping(ctx context.Context, req *mapping.RestoreMappingRequest) (*mapping.RestoreMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreMapping not implemented")
}

func RegisterMappingServiceServer(s *grpc.Server, srv MappingServiceServer) {
	s.RegisterService(&_MappingService_serviceDesc, srv)
}

func _MappingService_GetMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.MappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).GetMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/GetMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).GetMapping(ctx, req.(*mapping.MappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_SaveMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.SaveMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).SaveMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/SaveMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).SaveMapping(ctx, req.(*mapping.SaveMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_DeleteMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.DeleteMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).DeleteMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/DeleteMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).DeleteMapping(ctx, req.(*mapping.DeleteMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_DeleteRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.DeleteRepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).DeleteRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/DeleteRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).DeleteRepository(ctx, req.(*mapping.DeleteRepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_UpdateRepositoryDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.UpdateRepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).UpdateRepositoryDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/UpdateRepositoryDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).UpdateRepositoryDetails(ctx, req.(*mapping.UpdateRepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_UpdateEnvironment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.UpdateEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).UpdateEnvironment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/UpdateEnvironment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).UpdateEnvironment(ctx, req.(*mapping.UpdateEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_ExecuteAPI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.ExecuteApiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).ExecuteAPI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/ExecuteAPI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).ExecuteAPI(ctx, req.(*mapping.ExecuteApiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_ResolveExpressions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.ResolveExpressionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).ResolveExpressions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/ResolveExpressions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).ResolveExpressions(ctx, req.(*mapping.ResolveExpressionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingService_RestoreMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mapping.RestoreMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingServiceServer).RestoreMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.MappingService/RestoreMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingServiceServer).RestoreMapping(ctx, req.(*mapping.RestoreMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MappingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.MappingService",
	HandlerType: (*MappingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMapping",
			Handler:    _MappingService_GetMapping_Handler,
		},
		{
			MethodName: "SaveMapping",
			Handler:    _MappingService_SaveMapping_Handler,
		},
		{
			MethodName: "DeleteMapping",
			Handler:    _MappingService_DeleteMapping_Handler,
		},
		{
			MethodName: "DeleteRepository",
			Handler:    _MappingService_DeleteRepository_Handler,
		},
		{
			MethodName: "UpdateRepositoryDetails",
			Handler:    _MappingService_UpdateRepositoryDetails_Handler,
		},
		{
			MethodName: "UpdateEnvironment",
			Handler:    _MappingService_UpdateEnvironment_Handler,
		},
		{
			MethodName: "ExecuteAPI",
			Handler:    _MappingService_ExecuteAPI_Handler,
		},
		{
			MethodName: "ResolveExpressions",
			Handler:    _MappingService_ResolveExpressions_Handler,
		},
		{
			MethodName: "RestoreMapping",
			Handler:    _MappingService_RestoreMapping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mapping_service.proto",
}
